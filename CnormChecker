#!/bin/python3

import sys
import os
import stat
import re
import getopt

VERSION = "0.0.2"

p_err = "\033[1;31m[ERROR]\033[0m "
p_warn = "\033[1;33m[WARNING]\033[0m "

def check_header(checker, file, path):
    lcount = 0
    for line in file:
        if lcount == 0 and not re.search("^\/\*$", line):
            checker.major("G1", path, lcount, "Invalid file header !")
            break
        elif lcount == 1 and not re.search("^\*\* EPITECH PROJECT, (\d)+$", line):
            checker.major("G1", path, lcount, "Invalid file header !")
            break
        elif lcount == 2 and not re.search("^\*\* .+$", line):
            checker.major("G1", path, lcount, "Invalid file header !")
            break
        elif lcount == 3 and not re.search("^\*\* File description:$", line):
            checker.major("G1", path, lcount, "Invalid file header !")
            break
        elif lcount == 4 and not re.search("^\*\* .+$", line):
            checker.major("G1", path, lcount, "Invalid file header !")
            break
        elif lcount == 5 and not re.search("^\*\/$", line):
            checker.major("G1", path, lcount, "Invalid file header !")
            break
        elif lcount == 6:
            return lcount
        lcount += 1
    return lcount


class Makefile(object):

    def __init__(self, path, checker):
        super(Makefile, self).__init__()
        self.path = path
        self.checker = checker

    def check(self):
        print(self.path + ": Makefiles not handeled for now !\n")


class Hfile(object):

    def __init__(self, path, checker):
        super(Hfile, self).__init__()
        self.path = path
        self.checker = checker

    def check(self):
        print(self.path + ": Header files not handeled for now !\n")


class Cfile(object):

    def __init__(self, path, checker):
        super(Cfile, self).__init__()
        self.path = path
        self.checker = checker
    
    def check(self):
        with open(self.path, "r") as file:
            string = file.read().splitlines()
            headersize = check_header(self.checker, string, self.path)
            indent = []
            emptyLine = 0
            inBlockCounter = 0
            if getFuncNumber(string) > 5:
                self.checker.major("O3", self.path, None, "Too much functions in file !")
            for lcount, line in enumerate(string):
                if lcount < headersize:
                    continue
                elif lcount == headersize and line != "":
                    self.checker.info(None, self.path, lcount, "Missing new line after header !")
                elif lcount == headersize:
                    continue
                if len(line) > 80:
                    self.checker.major("F3", self.path, lcount, "The length of a line should not exceed 80 columns")
                if emptyLine == 1:
                    if line != "":
                        self.checker.minor("G2", self.path, lcount, "One and only one empty line should separate the implementation of functions")
                    emptyLine = 0
                elif emptyLine == 2:
                    emptyLine = 0
                elif line == "":
                    self.checker.minor("G2", self.path, lcount, "One and only one empty line should separate the implementation of functions")
                if re.search(".*\}.*", line) and not re.search(".*\{.*", line):
                    indent.pop()
                    if len(indent) == 0:
                        emptyLine = 1
                elif len(indent) == 0 and re.search("\#.*", line):
                    emptyLine = 2
                if len(indent) == 0 and line != "" and re.search("^ ", line):
                    self.checker.minor("L2", self.path, lcount, "Bad indentation")
                    if not self.checker.silent and self.checker.debug:
                        print("\033[1;31m", end="")
                elif len(indent) > 0 and line != "" and not re.search("^(    ){" + str(len(indent)) + "}\S+.*", line):
                    self.checker.minor("L2", self.path, lcount, "Bad indentation")
                    if not self.checker.silent and self.checker.debug:
                        print("\033[1;31m", end="")
                if not self.checker.silent and self.checker.debug:
                    print(indent, ": " + line + "\033[0m")
                if len(indent) > 0 and re.search(".*\/\/.*", line):
                    self.checker.minor("F6", self.path, lcount, "There should be no comment inside a function")
                if re.search(".*\{.*", line) and not re.search(".*\}.*", line):
                    indent.append("block")
                    if len(indent) > 3:
                        self.checker.minor("C1", self.path, lcount, "Conditional branching")
                elif re.search(".*for.*", line) or re.search(".*while.*", line) or re.search(".*if.*", line) or re.search(".*else if.*", line) or re.search(".*else.*", line):
                    indent.append("once")
                    if len(indent) > 3:
                        self.checker.minor("C1", self.path, lcount, "Conditional branching")
                elif len(indent) > 0 and indent[len(indent) - 1] == "once":
                    while indent[len(indent) - 1] == "once":
                        indent.pop()
                if len(indent) > 0:
                    inBlockCounter += 1
                else:
                    inBlockCounter = 0
                if inBlockCounter == 22:
                    self.checker.major("F4", self.path, lcount, "Too much lines in function !")
                elif inBlockCounter > 22 and not (inBlockCounter - 2) % 5:
                    self.checker.major("F4", self.path, lcount, "Too much lines in function (" + str(inBlockCounter - 1) + ") !")


class Checker(object):

    def __init__(self, isDebug, isRecursive, isSilent):
        super(Checker, self).__init__()
        self.maj = 0
        self.min = 0
        self.inf = 0
        self.debug = isDebug
        self.recursive = isRecursive
        self.silent = isSilent

    def major(self, err, file, line, msg):
        if not self.silent:
            print("\033[1;31m[MAJOR]\033[1m " + (err if err else ""))
            print(file + "\033[0m:" + (str(line + 1) + ": " if line else " ") + msg + "\n")
        self.maj += 1

    def minor(self, err, file, line, msg):
        if not self.silent:
            print("\033[1;32m[MINOR]\033[1m " + (err if err else ""))
            print(file + "\033[0m:" + (str(line + 1) + ": " if line else " ") + msg + "\n")
        self.min += 1

    def info(self, err, file, line, msg):
        if not self.silent:
            print("\033[1;34m[INFO]\033[1m " + (err if err else ""))
            print(file + "\033[0m:" + (str(line + 1) + ": " if line else " ") + msg + "\n")
        self.inf += 1

    def check_makefile(self, file):
        print(file + ": Makefiles not handeled for now !\n")

    def check_file(self, file):
        print("\n\033[1;36m", end="")
        print(file, ":\033[0m")
        if not os.access(file, os.R_OK):
            print(p_warn + file + ": Cannot read this file")
            return
        if file.endswith("/Makefile"):
            file = Makefile(file, self)
            file.check()
        elif file.endswith(".c"):
            file = Cfile(file, self)
            file.check()
        elif file.endswith(".h"):
            file = Hfile(file, self)
            file.check()
        else:
            self.major("O1 / O2", file, None, "Unknown file type !")

    def check_folder(self, path):
        if not is_snake_case(path):
            self.major("O4", path, None, "Folders names must respect the snake_case convention !")
        if not os.access(path, os.R_OK):
            print(p_warn + path + ": Cannot open this folder")
            return
        for element in os.listdir(path):
            if self.recursive and os.path.isdir(element) and not element.startswith(".") and element != "bonus":
                self.check_folder(path + "/" + element)
            elif not element.startswith("."):
                self.check_file(path + "/" + element)

    def endprint(self):
        print("\033[1;31m[MAJOR]\033[0m " + str(self.maj) + " | \033[1;32m[MINOR]\033[0m " + str(self.min) + " | \033[1;34m[INFO]\033[0m " + str(self.inf))


def is_snake_case(string):
    return string == string.lower()

def getFuncNumber(string):
    tmp = 0
    counter = 0
    for line in string:
        if (re.search(".*\(.*\)$", line)):
            tmp = 1
        elif tmp == 1 and line == "{":
            tmp = 0
            counter += 1
    return counter

def help():
    print("\033[0;36mCnormChecker\033[1;33m", VERSION, "\033[0m")
    print("\n\033[33mDEFAULT BEHAVIOR:\033[0m")
    print("\tCheck every files in the current folder recursively")
    print("\n\033[33mUSAGE:\033[0m")
    print("\t", sys.argv[0], "[OPTIONS] [FILES / FOLDERS]")
    print("\n\033[33mOPTIONS:\033[0m")
    print("\t\033[32m-h\033[0m,\033[32m--help\033[0m")
    print("\t\tPrint this help message.")
    print("\t\033[32m-v\033[0m,\033[32m--version\033[0m")
    print("\t\tShow version information.")
    print("\t\033[32m-s\033[0m,\033[32m--silent\033[0m")
    print("\t\tEnable silent mode.")
    print("\t\033[32m-D\033[0m,\033[32m--debug\033[0m")
    print("\t\tAdd some debug output.")
    print("\t\033[32m-R\033[0m,\033[32m--recursive\033[0m")
    print("\t\tEnable recursive mode.")
    print("\n\033[33mARGS:\033[0m")
    print("\t\033[32m<FILE>\033[0m")
    print("\t\tFile(s) to check.")
    print("\t\033[32m<FOLDER>\033[0m")
    print("\t\tFolder(s) that every files inside will be check.")
    print("\n© 2019 Louis Kleiver")

def version():
    print("\033[0;36mCnormChecker\033[1;33m", VERSION, "\033[0m")
    print("© 2019 Louis Kleiver")

def argError():
    print("\033[1;31mInvalid syntax :\033[0m")
    print("\tType '" + sys.argv[0] + " --help' for help.")
    exit(1)

def readFile(checker, file):
    try:
        md = os.stat(file).st_mode
    except:
        print(p_err + file + ": No such file or directory")
        exit(2)
    if stat.S_ISDIR(md):
        checker.check_folder(file)
    elif stat.S_ISREG(md):
        checker.check_file(file)
    else:
        print(p_err + file + ": Invalid file")

def main():
    args = sys.argv.copy()
    args.pop(0)
    try:
        optlist, args = getopt.getopt(args, "RDs", ["recursive", "debug", "silent"])
    except:
        argError()
    files = []
    recursive = False
    debug = False
    silent = False
    if len(args) <= 0:
        files.append(".")
        recursive = True
    else:
        for arg in args:
            files.append(arg)
        for opt in optlist:
            if (opt[0] == "-R" or opt[0] =="--recursive") and not opt[1]:
                recursive = True
            elif (opt[0] == "-D" or opt[0] =="--debug") and not opt[1]:
                debug = True
            elif (opt[0] == "-s" or opt[0] =="--silent") and not opt[1]:
                silent = True
            else:
                argError()
    checker = Checker(debug, recursive, silent)
    for file in files:
        readFile(checker, file)
    print()
    checker.endprint()

if __name__ == "__main__":
    if len(sys.argv) == 2:
        if sys.argv[1] == "-h" or sys.argv[1] == "--help":
            help()
            exit(0)
        elif sys.argv[1] == "-v" or sys.argv[1] == "--version":
            version()
            exit(0)
    main()